<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta content='width=device-width, initial-scale=1' name=viewport> <title>How We XP: Develop & Deploy | DWF’s Journal</title> <link href='/feed.xml' rel=alternate title='Atom Feed' type='application/atom+xml'> <link href='https://fonts.googleapis.com/css2?family=Fira+Mono&amp;family=Open+Sans:wght@400;700&amp;family=Raleway:wght@600;800&amp;display=swap' rel=stylesheet> <link href='/stylesheets/all-22061354.css' rel=stylesheet> <script type='application/ld+json'>
{"@context":"https://schema.org","@type":"BlogPosting","genre":"software development","headline":"DWF's Journal - How We XP: Develop & Deploy","url":"https://dwf.bigpencil.net/how-we-xp/","keywords":"software development,agile,xp,continuous integration,testing","author":{"@type":"Person","name":"Davis W. Frank","email":"dwfrank@gmail.com"},"datePublished":"2015-11-01","dateCreated":"2015-11-01","dateModified":"2021-05-15","description":null,"articleBody":"Originally written (and posted to Medium) for a friend who while around software for a while, and seen some agile teams, he was just starting to manage one directly. So I wrote up this bit of a braindump.\n&ndash;dwf \n\n\n\nI&rsquo;m not going to go into planning. That&rsquo;s another post.\n\nI&rsquo;m going to assume that stories &mdash; the work that is to be done &mdash; are broken into small, individually-acceptable pieces of work. &ldquo;Acceptable&rdquo; means that a Product Manager (PM) can verify that developers did the agreed work completely. Keeping the stories small means it is easier to make progress, show progress, and validate progress.\n\nI&rsquo;m also assuming that the team is using git for version control, the developers are test-driving their code (Test-driven Development or TDD), the current test suite is green on a Continuous Integration system (CI), and that we are talking about a web app.\n\nDevelopment\n\n\nAll new development is done locally\nDevelopers pull up to latest code and run the test suite. It should be green. If not, fix it and push back to origin before continuing.\nDevelopers test drive the new feature.\nWhen developers think the story is done based on the acceptance criteria agreed-upon with the PM, all tests should be green and the new functionality should be working as expected.\nThis is a great time for developers to find refactoring or dead code and clean those up as well. Tests should stay green.\nDevelopers now pull up to latest code from origin in case another part of the team has pushed new code. If there are changes, merge and run tests again. If there are broken tests, fix them before continuing.\nOptional: some teams like feature branches. They should be short-lived and merged/re-based with master often. The longer your changes stay away from master, the more tech debt you create. Merge early, merge often. Git-flow is a pretty good pattern here.\n= Once all tests are green locally and all changes are ahead of origin master, push to origin.\n\n\nContinuous Integration (CI)\n\n\nYour git repo should have a post-commit hook that starts a CI build. On every push to master, no exceptions.\nThis is a full test run on a server that looks as close to your Production deploy configuration as possible.\nThis can be a long pipeline. Run unit tests, run integrations and functional tests and regression tests - whatever. Often your pipeline will have later stages that integrate multiple apps/services and cross-browser tests. Make sure you are getting feedback at all stages of the pipeline.\nWhen CI is green all the way, you should have a CI step that deploys to Staging. This should happen several times per day. And if it&rsquo;s automated, even better.\n\n\nStaging (aka Acceptance)\n\n\nStaging is a deployment (or environment) that looks exactly like Production, with the same versions of OS, database, etc.\nStaging doesn&rsquo;t need to serve the same capacity &mdash; so maybe just a primary database (no replication or secondaries ). Since there will be fewer active users, you probably only need one app server.\nOptional: If your system has feature that needs acceptance that requires master/slave DB or app server failover, then by all means install/configure Staging to match that configuration.\nEveryone should know when a Staging deploy is done and what new work it contains. Notify the team via email or an information radiator.\nPM should verify work is done as expected on Staging. Validating that work is complete is PM&rsquo;s role, Not QA.\nIf work is not satisfactory, Reject the work. Rejected work should be started before any new work is started.\nIf something is broken that used to work, PM writes a bug. PM should prioritize bugs against other work. That is, a given bug may not be as important to fix as some new feature stories.\nQA should be looking at Staging to find bugs, problems, regressions, or any inconsistencies. They should be using the product as a user would and should be looking for behavior that engineering and product didn&rsquo;t find. This is often called exploratory QA. You should have your QA lead read the book on Exploratory QA, Explore It! written by my good friend and colleague, Elisabeth Hendrickson\n\n\nProduction\n\n\nProduction is where the shipping product lives.\nWhen all stories on Staging have been accepted, PM should consider pushing that version of the code to Production.\nIf users will have a bad experience due to known bugs or an incomplete user experience, then don&rsquo;t push to Production.\nPush to Production has often as possible.\n\n\nOther Deploys\n\nThis list is by no means exhaustive. But small-to-medium-sized projects tend to have one or more of these deploys.\n\nPatch Staging\n\nA copy of Staging, meant as a short-lived deploy just to verify a hot-fix. Using a second Staging means mainline work doesn&rsquo;t slow down while a patch is developed and shipped. Same rules as Staging apply, but tear this deploy down as soon as the fix is deployed to Production.\n\nDemo\n\nA copy of Staging, meant as a short-lived deploy for specific set of users for a short amount of time. Like a PatchGood use cases for a Demo deploy include demoing to potential investors and user research. Tear this deploy down as soon as the demo is over or when feedback is no longer required.\n\nIntegration/User Acceptance Test\n\nA copy of Staging that can be used for more real-world testing. This usually stays in line with the normal Staging and is used for CI pipelines. Some examples are performance testing, smoke testing, and long user scenario testing.\n\nNot Scary\n\nContinuous Delivery\n\nWhat&rsquo;s described above is Continuous Delivery; insist that code always move in one direction: towards Production. Also, set up the whole team so that it&rsquo;s easier to move towards Production and release often.\n\nProduction Patches\n\nHere&rsquo;s how you should deal with hot-fixes:\n\n\nDevelopers branch from the last Production deploy version.\nDevelopers fix the bug.\nCI runs against this version of the code to ensure no regressions.\nDevelopers deploy this version to a temporary Staging environment.\nPM accepts the fix.\nDevelopers push this branch to Production.\nDevelopers merge the fix back to master.\n\n\nSometimes Scary\n\nContinuous Deployment\n\nSome teams are able to push every green build to Production. I&rsquo;m not going to cover this in this post. But there is additional process and code needed to support this.\n\nScary\n\nThese are the things you should truly worry about.\n\nLong duration test suites\n\nWhen your test suite or CI pipeline is too long, you run the risk of completing work faster than you can verify it. If you keep locally-run suites fast - say, under 10–20 minutes - then your developers can get features to staging multiple times a day. Long CI pipelines are less awful. For example, a web app can have a multi-stage pipeline that puts an all-browser compatibility suite near the end. Main development can continue based on success of unit tests, collaboration tests, and one browser stage of tests. Then the multi-browser suite can run once or twice a day, and browser-based problems from that stage can be bugs that get prioritized against other work.\n\nLong-lived branches\n\nLike long test suites, this can keep your feedback loops long. In this case you have bigger risks around the rest of your app changing faster than the branch&rsquo;s work can keep up. If it&rsquo;s taking too long to merge something back to master, then consider that the work should be broken up into smaller bits or should be started when its dependencies are more stable.\n\nComplex merges\n\nThis usually comes from long-lived branches. Keeping all development on master helps to minimize this.\n\nManual deployment\n\n&hellip;either manual configurations and/or inconsistent deployments from Product &amp; Staging. These are often related. You want Staging, Production, and any other deploys to have consistent configuration. Bugs due to different code interpreters, databases or OS libraries are very subtle and guaranteed time wasters. Invest in DevOps or a Platform-as-a-Service (PaaS) in order to keep your deploys consistent and repeatable.\n\nBreaking the Stream\n\nCode should always move towards Production. It increases the confidence in the code and keeps regressions low. When a fix is made downstream of development, then it&rsquo;s harder than normal development to integrate that fix back in development.\n"}
</script> </head> <body> <nav> <a href='/'>Home</a> <a href='/about_me'>About Me</a> <a href='/posts'>All Posts</a> </nav> <main class=wrapper> <article class=post> <header> <h1> How We XP: Develop & Deploy </h1> <h2 class=date> 1 November 2015 &#8212; about a 7 minute read </h2> </header> <section id=post-body><p><em>Originally written (and posted to <a href="https://medium.com/@dwfrank/how-we-xp-develop-deploy-13faf089420b">Medium</a>) for a friend who while around software for a while, and seen some agile teams, he was just starting to manage one directly. So I wrote up this bit of a braindump. <br/><br/>&ndash;dwf</em> </p> <hr> <p>I&rsquo;m not going to go into planning. That&rsquo;s another post.</p> <p>I&rsquo;m going to assume that stories &mdash; the work that is to be done &mdash; are broken into small, individually-acceptable pieces of work. &ldquo;Acceptable&rdquo; means that a Product Manager (PM) can verify that developers did the agreed work completely. Keeping the stories small means it is easier to make progress, show progress, and validate progress.</p> <p>I&rsquo;m also assuming that the team is using git for version control, the developers are test-driving their code (Test-driven Development or TDD), the current test suite is green on a Continuous Integration system (CI), and that we are talking about a web app.</p> <h2>Development</h2> <ul> <li>All new development is done locally</li> <li>Developers pull up to latest code and run the test suite. It should be green. If not, fix it and push back to origin before continuing.</li> <li>Developers test drive the new feature.</li> <li>When developers think the story is done based on the acceptance criteria agreed-upon with the PM, all tests should be green and the new functionality should be working as expected.</li> <li>This is a great time for developers to find refactoring or dead code and clean those up as well. Tests should stay green.</li> <li>Developers now pull up to latest code from origin in case another part of the team has pushed new code. If there are changes, merge and run tests again. If there are broken tests, fix them before continuing.</li> <li>Optional: some teams like feature branches. They should be short-lived and merged/re-based with master often. The longer your changes stay away from master, the more tech debt you create. Merge early, merge often. Git-flow is a pretty good pattern here. = Once all tests are green locally and all changes are ahead of origin master, push to origin.</li> </ul> <h2>Continuous Integration (CI)</h2> <ul> <li>Your git repo should have a post-commit hook that starts a CI build. On every push to master, no exceptions.</li> <li>This is a full test run on a server that looks as close to your Production deploy configuration as possible.</li> <li>This can be a long pipeline. Run unit tests, run integrations and functional tests and regression tests - whatever. Often your pipeline will have later stages that integrate multiple apps/services and cross-browser tests. Make sure you are getting feedback at all stages of the pipeline.</li> <li>When CI is green all the way, you should have a CI step that deploys to Staging. This should happen several times per day. And if it&rsquo;s automated, even better.</li> </ul> <h2>Staging (aka Acceptance)</h2> <ul> <li>Staging is a deployment (or environment) that looks exactly like Production, with the same versions of OS, database, etc.</li> <li>Staging doesn&rsquo;t need to serve the same capacity &mdash; so maybe just a primary database (no replication or secondaries ). Since there will be fewer active users, you probably only need one app server.</li> <li>Optional: If your system has feature that needs acceptance that requires master/slave DB or app server failover, then by all means install/configure Staging to match that configuration.</li> <li>Everyone should know when a Staging deploy is done and what new work it contains. Notify the team via email or an information radiator.</li> <li>PM should verify work is done as expected on Staging. Validating that work is complete is PM&rsquo;s role, Not QA.</li> <li>If work is not satisfactory, Reject the work. Rejected work should be started before any new work is started.</li> <li>If something is broken that used to work, PM writes a bug. PM should prioritize bugs against other work. That is, a given bug may not be as important to fix as some new feature stories.</li> <li>QA should be looking at Staging to find bugs, problems, regressions, or any inconsistencies. They should be using the product as a user would and should be looking for behavior that engineering and product didn&rsquo;t find. This is often called exploratory QA. You should have your QA lead read the book on Exploratory QA, <a href="https://www.amazon.com/Explore-Increase-Confidence-Exploratory-Testing/dp/1937785025">Explore It!</a> written by my good friend and colleague, <a href="https://twitter.com/testobsessed">Elisabeth Hendrickson</a></li> </ul> <h2>Production</h2> <ul> <li>Production is where the shipping product lives.</li> <li>When all stories on Staging have been accepted, PM should consider pushing that version of the code to Production.</li> <li>If users will have a bad experience due to known bugs or an incomplete user experience, then don&rsquo;t push to Production.</li> <li>Push to Production has often as possible.</li> </ul> <h2>Other Deploys</h2> <p>This list is by no means exhaustive. But small-to-medium-sized projects tend to have one or more of these deploys.</p> <h3>Patch Staging</h3> <p>A copy of Staging, meant as a short-lived deploy just to verify a hot-fix. Using a second Staging means mainline work doesn&rsquo;t slow down while a patch is developed and shipped. Same rules as Staging apply, but tear this deploy down as soon as the fix is deployed to Production.</p> <h3>Demo</h3> <p>A copy of Staging, meant as a short-lived deploy for specific set of users for a short amount of time. Like a PatchGood use cases for a Demo deploy include demoing to potential investors and user research. Tear this deploy down as soon as the demo is over or when feedback is no longer required.</p> <h3>Integration/User Acceptance Test</h3> <p>A copy of Staging that can be used for more real-world testing. This usually stays in line with the normal Staging and is used for CI pipelines. Some examples are performance testing, smoke testing, and long user scenario testing.</p> <h2>Not Scary</h2> <h3>Continuous Delivery</h3> <p>What&rsquo;s described above is Continuous Delivery; insist that code always move in one direction: towards Production. Also, set up the whole team so that it&rsquo;s easier to move towards Production and release often.</p> <h3>Production Patches</h3> <p>Here&rsquo;s how you should deal with hot-fixes:</p> <ul> <li>Developers branch from the last Production deploy version.</li> <li>Developers fix the bug.</li> <li>CI runs against this version of the code to ensure no regressions.</li> <li>Developers deploy this version to a temporary Staging environment.</li> <li>PM accepts the fix.</li> <li>Developers push this branch to Production.</li> <li>Developers merge the fix back to master.</li> </ul> <h2>Sometimes Scary</h2> <h3>Continuous Deployment</h3> <p>Some teams are able to push <em>every</em> green build to Production. I&rsquo;m not going to cover this in this post. But there is additional process and code needed to support this.</p> <h2>Scary</h2> <p>These are the things you should truly worry about.</p> <h3>Long duration test suites</h3> <p>When your test suite or CI pipeline is too long, you run the risk of completing work faster than you can verify it. If you keep locally-run suites fast - say, under 10–20 minutes - then your developers can get features to staging multiple times a day. Long CI pipelines are less awful. For example, a web app can have a multi-stage pipeline that puts an all-browser compatibility suite near the end. Main development can continue based on success of unit tests, collaboration tests, and one browser stage of tests. Then the multi-browser suite can run once or twice a day, and browser-based problems from that stage can be bugs that get prioritized against other work.</p> <h3>Long-lived branches</h3> <p>Like long test suites, this can keep your feedback loops long. In this case you have bigger risks around the rest of your app changing faster than the branch&rsquo;s work can keep up. If it&rsquo;s taking too long to merge something back to master, then consider that the work should be broken up into smaller bits or should be started when its dependencies are more stable.</p> <h3>Complex merges</h3> <p>This usually comes from long-lived branches. Keeping all development on master helps to minimize this.</p> <h3>Manual deployment</h3> <p>&hellip;either manual configurations and/or inconsistent deployments from Product &amp; Staging. These are often related. You want Staging, Production, and any other deploys to have consistent configuration. Bugs due to different code interpreters, databases or OS libraries are very subtle and guaranteed time wasters. Invest in DevOps or a Platform-as-a-Service (PaaS) in order to keep your deploys consistent and repeatable.</p> <h3>Breaking the Stream</h3> <p>Code should always move towards Production. It increases the confidence in the code and keeps regressions low. When a fix is made downstream of development, then it&rsquo;s harder than normal development to integrate that fix back in development.</p> </section> <footer id=article>This article is tagged with <a href="/tags/career/">career</a> and <a href="/tags/agile/">agile</a>.</footer> </article> <footer id=post-meta> <a href='/'> <img alt=Avatar class=avatar src='/images/dwf-d2380e10.png'> <div class=details> <div class=dark>Davis W. Frank</div> <div class=light>A computer is just a BIG. PENCIL.</div> </div> </a> <div class=sharing> <a href='https://twitter.com/share?text=How We XP: Develop &amp; Deploy&amp;url=https://dwf.bigpencil.net/how-we-xp/&amp;via=dwfrank'> <span class='fab fa-twitter-square'></span> </a> <a href='mailto:?subject=How We XP: Develop &amp; Deploy&amp;body=https://dwf.bigpencil.net/how-we-xp/'> <span class='fas fa-envelope-square'></span> </a> <a href='https://www.facebook.com/sharer/sharer.php?u=https://dwf.bigpencil.net/how-we-xp/'> <span class='fab fa-facebook-square'></span> </a> </div> </footer> <footer class=site> <p class=small>© Davis W. Frank 2022</p> </footer> </main> <script async='' src='https://www.googletagmanager.com/gtag/js?id=G-SNXCW3490N'></script> <script>
window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date());
gtag('config', 'G-SNXCW3490N');
</script> </body> </html>